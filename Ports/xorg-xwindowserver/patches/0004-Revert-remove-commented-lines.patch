From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Karol Kosek <krkk@serenityos.org>
Date: Tue, 5 Aug 2025 22:23:36 +0200
Subject: [PATCH] Revert "remove commented lines"

This reverts commit e013328afdfe819217116a3a648f95897964f7c4.
---
 hw/xwindowserver/xwindowserver-input.c  |  30 ++
 hw/xwindowserver/xwindowserver-screen.c | 141 ++++++
 hw/xwindowserver/xwindowserver-screen.h |  10 +
 hw/xwindowserver/xwindowserver-window.c | 567 ++++++++++++++++++++++++
 hw/xwindowserver/xwindowserver-window.h |  39 ++
 hw/xwindowserver/xwindowserver.c        |  11 +
 6 files changed, 798 insertions(+)

diff --git a/hw/xwindowserver/xwindowserver-input.c b/hw/xwindowserver/xwindowserver-input.c
index 7171b7a8e85c958923f3181d13f3e3a1b81bc026..a90b09fe9a8a15907e9f67082a5bde99878da607 100644
--- a/hw/xwindowserver/xwindowserver-input.c
+++ b/hw/xwindowserver/xwindowserver-input.c
@@ -50,6 +50,29 @@ ProcessInputEvents(void)
 void
 DDXRingBell(int volume, int pitch, int duration)
 {
+/*    ScreenPtr screen = screenInfo.screens[0];
+    struct xwl_screen *xwl_screen;
+    struct xwl_seat *xwl_seat;
+
+    xwl_screen = xwl_screen_get(screen);
+    if (!xwl_screen->system_bell)
+        return;
+
+    xorg_list_for_each_entry(xwl_seat, &xwl_screen->seat_list, link) {
+        if (!xwl_seat->keyboard)
+            continue;
+
+        if (!xwl_seat->keyboard->coreEvents)
+            continue;
+
+        if (!xwl_seat->keyboard_focus)
+            continue;
+
+        DebugF("XWAYLAND: Ringing the bell\n");
+        xdg_system_bell_v1_ring (xwl_screen->system_bell, xwl_seat->keyboard_focus);
+        return;
+    }
+*/
 }
 
 void
@@ -64,6 +87,13 @@ InitInput(int argc, char *argv[])
     }
 
     mieqInit();
+/*
+    inputInfo.keyboard->ignoreXkbActionsBehaviors = TRUE;
+    xwl_screen->XYToWindow = pScreen->XYToWindow;
+    pScreen->XYToWindow = xwl_xy_to_window;
+
+    xwl_screen_roundtrip(xwl_screen);
+*/
 }
 
 void
diff --git a/hw/xwindowserver/xwindowserver-screen.c b/hw/xwindowserver/xwindowserver-screen.c
index f95f39689dc30da7ddec625db7eac34754938471..8a76ac37973c72980c3d40cf704da3da0c106100 100644
--- a/hw/xwindowserver/xwindowserver-screen.c
+++ b/hw/xwindowserver/xwindowserver-screen.c
@@ -62,14 +62,26 @@ static DevPrivateKeyRec xwl_client_private_key;
 Bool
 xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
 {
+    //static const char allow_commits[] = "_XWAYLAND_ALLOW_COMMITS";
     struct xwl_screen *xwl_screen;
     Pixel red_mask, blue_mask, green_mask;
     int ret, bpc, green_bpc, i;
+    //unsigned int xwl_width = 640;
+    //unsigned int xwl_height = 480;
 
     if (!dixRegisterPrivateKey(&xwl_screen_private_key, PRIVATE_SCREEN, 0))
         return FALSE;
+    //if (!xwl_pixmap_init())
+    //    return FALSE;
     if (!xwl_window_init())
         return FALSE;
+    /* There are no easy to use new / delete client hooks, we could use a
+     * ClientStateCallback, but it is easier to let the dix code manage the
+     * memory for us. This will zero fill the initial xwl_client data.
+     */
+    //if (!dixRegisterPrivateKey(&xwl_client_private_key, PRIVATE_CLIENT,
+    //                           sizeof(struct xwl_client)))
+    //    return FALSE;
 
     xwl_screen = calloc(1, sizeof *xwl_screen);
     if (xwl_screen == NULL)
@@ -93,12 +105,76 @@ xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
             defaultScreenSaverInterval = 0;
         }
     }
+#if 0
+    xwl_screen->display = wl_display_connect(NULL);
+    if (xwl_screen->display == NULL) {
+        ErrorF("could not connect to wayland server\n");
+        return FALSE;
+    }
+
+    /* In rootless mode, we don't have any screen storage, and the only
+     * rendering should be to redirected mode. */
+    if (xwl_screen->rootless)
+        xwl_screen->root_clip_mode = ROOT_CLIP_INPUT_ONLY;
+    else
+        xwl_screen->root_clip_mode = ROOT_CLIP_FULL;
 
+    xorg_list_init(&xwl_screen->output_list);
+    xorg_list_init(&xwl_screen->seat_list);
+    xorg_list_init(&xwl_screen->damage_window_list);
+    xorg_list_init(&xwl_screen->window_list);
+    xorg_list_init(&xwl_screen->drm_lease_devices);
+    xorg_list_init(&xwl_screen->queued_drm_lease_devices);
+    xorg_list_init(&xwl_screen->drm_leases);
+    xorg_list_init(&xwl_screen->pending_wl_surface_destroy);
+#endif
     xwl_screen->depth = 24;
+    //xwl_screen->global_surface_scale = 1;
 
     if (!monitorResolution)
         monitorResolution = DEFAULT_DPI;
 
+#if 0
+    if (use_fixed_size) {
+        if (!xwl_screen_init_randr_fixed(xwl_screen))
+            return FALSE;
+    } else {
+        if (!xwl_screen_init_output(xwl_screen))
+            return FALSE;
+    }
+
+    xwl_screen->expecting_event = 0;
+    xwl_screen->registry = wl_display_get_registry(xwl_screen->display);
+    wl_registry_add_listener(xwl_screen->registry,
+                             &registry_listener, xwl_screen);
+    xwl_screen_roundtrip(xwl_screen);
+
+
+    if (xwl_screen->fullscreen && xwl_screen->rootless) {
+        ErrorF("error, cannot set fullscreen when running rootless\n");
+        return FALSE;
+    }
+
+    if (xwl_screen->fullscreen && xwl_screen->decorate) {
+        ErrorF("error, cannot use the decorate option when running fullscreen\n");
+        return FALSE;
+    }
+
+    if (xwl_screen->fullscreen && !xwl_screen_has_viewport_support(xwl_screen)) {
+        ErrorF("missing viewport support in the compositor, ignoring fullscreen\n");
+        xwl_screen->fullscreen = FALSE;
+    }
+
+    if (xwl_screen->host_grab && xwl_screen->rootless) {
+        ErrorF("error, cannot use host grab when running rootless\n");
+        return FALSE;
+    }
+
+    if (!xwl_screen->rootless && !xwl_screen->xdg_wm_base) {
+        ErrorF("missing XDG-WM-Base protocol\n");
+        return FALSE;
+    }
+#endif
     bpc = xwl_screen->depth / 3;
     green_bpc = xwl_screen->depth - 2 * bpc;
     blue_mask = (1 << bpc) - 1;
@@ -122,14 +198,79 @@ xwl_screen_init(ScreenPtr pScreen, int argc, char **argv)
 
     fbPictureInit(pScreen, 0, 0);
 
+    //{
+    //    xwl_screen->wayland_fd = wl_display_get_fd(xwl_screen->display);
+    //}
+    //SetNotifyFd(xwl_screen->wayland_fd, socket_handler, X_NOTIFY_READ, xwl_screen);
+    //RegisterBlockAndWakeupHandlers(block_handler, wakeup_handler, xwl_screen);
+
     pScreen->blackPixel = 0;
     pScreen->whitePixel = 1;
 
     ret = fbCreateDefColormap(pScreen);
+#if 0
+    if (!xwl_screen_init_cursor(xwl_screen))
+        return FALSE;
 
+    xwl_screen->present = xwl_present_init(pScreen);
+
+    if (!xwl_screen->glamor) {
+        xwl_screen->CreateScreenResources = pScreen->CreateScreenResources;
+        pScreen->CreateScreenResources = xwl_shm_create_screen_resources;
+        pScreen->CreatePixmap = xwl_shm_create_pixmap;
+        pScreen->DestroyPixmap = xwl_shm_destroy_pixmap;
+    }
+#endif
     xwl_screen->RealizeWindow = pScreen->RealizeWindow;
     pScreen->RealizeWindow = xwl_realize_window;
+#if 0
+    xwl_screen->UnrealizeWindow = pScreen->UnrealizeWindow;
+    pScreen->UnrealizeWindow = xwl_unrealize_window;
+
+    xwl_screen->DestroyWindow = pScreen->DestroyWindow;
+    pScreen->DestroyWindow = xwl_destroy_window;
+
+    xwl_screen->CloseScreen = pScreen->CloseScreen;
+    pScreen->CloseScreen = xwl_close_screen;
+
+    xwl_screen->ChangeWindowAttributes = pScreen->ChangeWindowAttributes;
+    pScreen->ChangeWindowAttributes = xwl_change_window_attributes;
+
+    xwl_screen->ClipNotify = pScreen->ClipNotify;
+    pScreen->ClipNotify = xwl_clip_notify;
+
+    xwl_screen->ConfigNotify = pScreen->ConfigNotify;
+    pScreen->ConfigNotify = xwl_config_notify;
 
+    xwl_screen->ResizeWindow = pScreen->ResizeWindow;
+    pScreen->ResizeWindow = xwl_resize_window;
+
+    xwl_screen->MoveWindow = pScreen->MoveWindow;
+    pScreen->MoveWindow = xwl_move_window;
+
+    xwl_screen->SetWindowPixmap = pScreen->SetWindowPixmap;
+    pScreen->SetWindowPixmap = xwl_window_set_window_pixmap;
+
+    xwl_screen->SetShape = pScreen->SetShape;
+    pScreen->SetShape = xwl_set_shape;
+
+    pScreen->CursorWarpedTo = xwl_cursor_warped_to;
+    pScreen->CursorConfinedTo = xwl_cursor_confined_to;
+
+    xwl_screen->allow_commits_prop = MakeAtom(allow_commits,
+                                              strlen(allow_commits),
+                                              TRUE);
+    if (xwl_screen->allow_commits_prop == BAD_RESOURCE)
+        return FALSE;
+
+    AddCallback(&PropertyStateCallback, xwl_property_callback, pScreen);
+    AddCallback(&RootWindowFinalizeCallback, xwl_root_window_finalized_callback, pScreen);
+    XaceRegisterCallback(XACE_PROPERTY_ACCESS, xwl_access_property_callback, pScreen);
+
+    xwl_screen_setup_custom_vector(xwl_screen);
+
+    xwl_screen_roundtrip(xwl_screen);
+#endif
     return ret;
 }
 
diff --git a/hw/xwindowserver/xwindowserver-screen.h b/hw/xwindowserver/xwindowserver-screen.h
index 86cd8c98926f53d10d3c7f824c8f10cfa9eb93c3..f35f97c90f79d4bfefe80f5c951700eb863c5f7e 100644
--- a/hw/xwindowserver/xwindowserver-screen.h
+++ b/hw/xwindowserver/xwindowserver-screen.h
@@ -26,11 +26,17 @@
 #ifndef XWAYLAND_SCREEN_H
 #define XWAYLAND_SCREEN_H
 
+//#include <xwayland-config.h>
+
 #include <stdio.h>
 #include <unistd.h>
 #include <X11/X.h>
 #include <dix.h>
 
+#ifdef XWL_HAS_LIBDECOR
+#include <libdecor.h>
+#endif
+
 struct xwl_screen {
     int depth;
     ScreenPtr screen;
@@ -79,6 +85,10 @@ struct xwl_screen {
 
     /* The preferred GLVND vendor. If NULL, "mesa" is assumed. */
     const char *glvnd_vendor;
+#ifdef XWL_HAS_LIBDECOR
+    int libdecor_fd;
+    struct libdecor *libdecor_context;
+#endif
     const char *output_name;
 
     uint32_t present_capabilities;
diff --git a/hw/xwindowserver/xwindowserver-window.c b/hw/xwindowserver/xwindowserver-window.c
index 17f95ead954eef680eb054312e5a0688369cf75f..e3aefb072f2dc95d2b8782198626957304448761 100644
--- a/hw/xwindowserver/xwindowserver-window.c
+++ b/hw/xwindowserver/xwindowserver-window.c
@@ -134,6 +134,12 @@ send_surface_id_event_serial(struct xwl_window *xwl_window)
 
     if (type_atom == None)
         type_atom = MakeAtom(atom_name, strlen(atom_name), TRUE);
+
+    //serial = ++xwl_window->xwl_screen->surface_association_serial;
+
+    //send_window_client_message(xwl_window, type_atom, serial);
+
+    /* Flush wayland display *after* commit in the new path. */
 }
 
 static void
@@ -168,8 +174,540 @@ xwl_window_init_allow_commits(struct xwl_window *xwl_window)
     ret = dixLookupProperty(&prop, xwl_window->toplevel,
                             xwl_window->xwl_screen->allow_commits_prop,
                             serverClient, DixReadAccess);
+    //if (ret == Success && prop)
+    //    xwl_window_set_allow_commits_from_property(xwl_window, prop);
+    //else
+    //    xwl_window_set_allow_commits(xwl_window, TRUE, "no property");
+}
+
+
+#if 0
+static void
+xwl_window_set_xwayland_tag(struct xwl_window *xwl_window)
+{
+}
+
+static void
+xwl_window_clear_xwayland_tag(struct xwl_window *xwl_window)
+{
+}
+
+static void
+xwl_window_set_allow_commits(struct xwl_window *xwl_window, Bool allow,
+                             const char *debug_msg)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    DamagePtr damage;
+
+    xwl_window->allow_commits = allow;
+    DebugF("XWAYLAND: win %d allow_commits = %d (%s)\n",
+           xwl_window->toplevel->drawable.id, allow, debug_msg);
+
+    damage = window_get_damage(xwl_window->surface_window);
+    if (allow &&
+        xorg_list_is_empty(&xwl_window->link_damage) &&
+        damage &&
+        RegionNotEmpty(DamageRegion(damage))) {
+        xorg_list_add(&xwl_window->link_damage,
+                      &xwl_screen->damage_window_list);
+    }
+}
+
+static void
+xwl_window_set_allow_commits_from_property(struct xwl_window *xwl_window,
+                                           PropertyPtr prop)
+{
+    static Bool warned = FALSE;
+    CARD32 *propdata;
+
+    if (prop->propertyName != xwl_window->xwl_screen->allow_commits_prop)
+        FatalError("Xwayland internal error: prop mismatch in %s.\n", __func__);
+
+    if (prop->type != XA_CARDINAL || prop->format != 32 || prop->size != 1) {
+        /* Not properly set, so fall back to safe and glitchy */
+        xwl_window_set_allow_commits(xwl_window, TRUE, "WM fault");
+
+        if (!warned) {
+            LogMessageVerb(X_WARNING, 0, "Window manager is misusing property %s.\n",
+                           NameForAtom(prop->propertyName));
+            warned = TRUE;
+        }
+        return;
+    }
+
+    propdata = prop->data;
+    xwl_window_set_allow_commits(xwl_window, !!propdata[0], "from property");
 }
 
+static void
+need_source_validate_dec(struct xwl_screen *xwl_screen)
+{
+    xwl_screen->need_source_validate--;
+
+    if (!xwl_screen->need_source_validate)
+        xwl_screen->screen->SourceValidate = xwl_screen->SourceValidate;
+}
+
+static void
+xwl_source_validate(DrawablePtr drawable, int x, int y, int width, int height,
+                    unsigned int sub_window_mode)
+{
+    struct xwl_window *xwl_window;
+    WindowPtr window, iterator;
+    RegionRec region;
+    BoxRec box;
+
+    if (sub_window_mode != IncludeInferiors ||
+        drawable->type != DRAWABLE_WINDOW)
+        return;
+
+    window = (WindowPtr)drawable;
+    xwl_window = xwl_window_from_window(window);
+    if (!xwl_window || !xwl_window->surface_window_damage ||
+        !RegionNotEmpty(xwl_window->surface_window_damage))
+        return;
+
+    for (iterator = xwl_window->toplevel;
+         ;
+         iterator = iterator->firstChild) {
+        if (iterator == xwl_window->surface_window)
+            return;
+
+        if (iterator == window)
+            break;
+    }
+
+    box.x1 = x;
+    box.y1 = y;
+    box.x2 = x + width;
+    box.y2 = y + height;
+    RegionInit(&region, &box, 1);
+    RegionIntersect(&region, &region, xwl_window->surface_window_damage);
+
+    if (RegionNotEmpty(&region)) {
+        ScreenPtr screen = drawable->pScreen;
+        PixmapPtr dst_pix, src_pix;
+        BoxPtr pbox;
+        GCPtr pGC;
+        int nbox;
+
+        dst_pix = screen->GetWindowPixmap(window);
+        pGC = GetScratchGC(dst_pix->drawable.depth, screen);
+        if (!pGC)
+            FatalError("GetScratchGC failed for depth %d", dst_pix->drawable.depth);
+        ValidateGC(&dst_pix->drawable, pGC);
+
+        src_pix = screen->GetWindowPixmap(xwl_window->surface_window);
+
+        RegionSubtract(xwl_window->surface_window_damage,
+                       xwl_window->surface_window_damage,
+                       &region);
+
+        if (!RegionNotEmpty(xwl_window->surface_window_damage))
+            need_source_validate_dec(xwl_window->xwl_screen);
+
+#if defined(COMPOSITE)
+        if (dst_pix->screen_x || dst_pix->screen_y)
+            RegionTranslate(&region, -dst_pix->screen_x, -dst_pix->screen_y);
+#endif
+
+        pbox = RegionRects(&region);
+        nbox = RegionNumRects(&region);
+        while (nbox--) {
+            (void) (*pGC->ops->CopyArea) (&src_pix->drawable,
+                                          &dst_pix->drawable,
+                                          pGC,
+                                          pbox->x1, pbox->y1,
+                                          pbox->x2 - pbox->x1, pbox->y2 - pbox->y1,
+                                          pbox->x1, pbox->y1);
+            pbox++;
+        }
+        FreeScratchGC(pGC);
+    }
+
+    RegionUninit(&region);
+}
+
+static void
+need_source_validate_inc(struct xwl_screen *xwl_screen)
+{
+    if (!xwl_screen->need_source_validate) {
+        ScreenPtr screen = xwl_screen->screen;
+
+        xwl_screen->SourceValidate = screen->SourceValidate;
+        screen->SourceValidate = xwl_source_validate;
+    }
+
+    xwl_screen->need_source_validate++;
+}
+
+static void
+damage_report(DamagePtr pDamage, RegionPtr pRegion, void *data)
+{
+    struct xwl_window *xwl_window = data;
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    PixmapPtr window_pixmap;
+
+    if (xwl_window->surface_window_damage &&
+        RegionNotEmpty(pRegion)) {
+        if (!RegionNotEmpty(xwl_window->surface_window_damage))
+            need_source_validate_inc(xwl_screen);
+
+        RegionUnion(xwl_window->surface_window_damage,
+                    xwl_window->surface_window_damage,
+                    DamageRegion(pDamage));
+    }
+
+    if (xwl_screen->ignore_damage)
+        return;
+
+    if (xorg_list_is_empty(&xwl_window->link_damage))
+        xorg_list_add(&xwl_window->link_damage, &xwl_screen->damage_window_list);
+
+    window_pixmap = xwl_screen->screen->GetWindowPixmap(xwl_window->surface_window);
+}
+
+static void
+damage_destroy(DamagePtr pDamage, void *data)
+{
+}
+
+static Bool
+register_damage(struct xwl_window *xwl_window)
+{
+    WindowPtr surface_window = xwl_window->surface_window;
+    DamagePtr damage;
+
+    damage = DamageCreate(damage_report, damage_destroy, DamageReportNonEmpty,
+                          FALSE, surface_window->drawable.pScreen, xwl_window);
+    if (damage == NULL) {
+        ErrorF("Failed creating damage\n");
+        return FALSE;
+    }
+
+    DamageRegister(&surface_window->drawable, damage);
+    dixSetPrivate(&surface_window->devPrivates, &xwl_damage_private_key, damage);
+
+    return TRUE;
+}
+
+static void
+unregister_damage(struct xwl_window *xwl_window)
+{
+    WindowPtr surface_window = xwl_window->surface_window;
+    DamagePtr damage;
+
+    damage = dixLookupPrivate(&surface_window->devPrivates, &xwl_damage_private_key);
+    if (!damage)
+        return;
+
+    DamageUnregister(damage);
+    DamageDestroy(damage);
+
+    dixSetPrivate(&surface_window->devPrivates, &xwl_damage_private_key, NULL);
+}
+
+static Bool
+xwl_window_update_fractional_scale(struct xwl_window *xwl_window,
+                                   int fractional_scale_numerator)
+{
+    int old_scale_numerator = xwl_window->fractional_scale_numerator;
+
+    xwl_window->fractional_scale_numerator = fractional_scale_numerator;
+
+    return (old_scale_numerator != fractional_scale_numerator);
+}
+
+static double
+xwl_window_get_fractional_scale_factor(struct xwl_window *xwl_window)
+{
+    return (double) xwl_window->fractional_scale_numerator /
+           (double) FRACTIONAL_SCALE_DENOMINATOR;
+}
+
+static Bool
+xwl_window_has_viewport_enabled(struct xwl_window *xwl_window)
+{
+    return (xwl_window->viewport != NULL);
+}
+
+static void
+xwl_window_disable_viewport(struct xwl_window *xwl_window)
+{
+    assert (xwl_window->viewport);
+
+    DebugF("XWAYLAND: disabling viewport\n");
+    xwl_window->viewport = NULL;
+    xwl_window->viewport_scale_x = 1.0;
+    xwl_window->viewport_scale_y = 1.0;
+}
+
+/* Enable the viewport for fractional scale support with Xwayland rootful.
+ * Fractional scale support is not used with Xwayland rootful fullscreen (which
+ * sets its own XRandR resolution) so we can use the viewport for either
+ * fullscreen mode or fractional scale.
+ */
+static void
+xwl_window_enable_viewport_for_fractional_scale(struct xwl_window *xwl_window,
+                                                int width, int height)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    int buffer_width, buffer_height;
+    double scale;
+
+    scale = xwl_window_get_fractional_scale_factor(xwl_window);
+    buffer_width = round((double) width / scale);
+    buffer_height = round((double) height / scale);
+
+    DebugF("XWAYLAND: enabling viewport for fractional scale %dx%d -> %dx%d\n",
+           width, height, buffer_width, buffer_height);
+
+    xwl_window->viewport_scale_x = scale;
+    xwl_window->viewport_scale_y = scale;
+}
+
+static Bool
+window_is_wm_window(WindowPtr window)
+{
+    struct xwl_screen *xwl_screen = xwl_screen_get(window->drawable.pScreen);
+
+    //return CLIENT_ID(window->drawable.id) == xwl_screen->wm_client_id;
+    return TRUE;
+}
+
+static WindowPtr
+window_get_client_toplevel(WindowPtr window)
+{
+    assert(window);
+
+    /* If the toplevel window is owned by the window-manager, then the
+     * actual client toplevel window has been reparented to some window-manager
+     * decoration/wrapper windows. In that case recurse by checking the client
+     * of the first *and only* child of the decoration/wrapper window.
+     */
+    while (window_is_wm_window(window)) {
+        if (!window->firstChild || window->firstChild != window->lastChild)
+            return NULL; /* Should never happen, skip resolution emulation */
+
+        window = window->firstChild;
+    }
+
+    return window;
+}
+
+static Bool
+xwl_window_should_enable_fractional_scale_viewport(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    double scale;
+
+    if (!xwl_screen_should_use_fractional_scale(xwl_screen))
+        return FALSE;
+
+    scale = xwl_window_get_fractional_scale_factor(xwl_window);
+
+    return fabs(scale - 1.00) > FLT_EPSILON;
+}
+
+static void
+xwl_window_check_fractional_scale_viewport(struct xwl_window *xwl_window,
+                                           int width, int height)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (!xwl_screen_should_use_fractional_scale(xwl_screen))
+        return;
+
+    if (xwl_window_should_enable_fractional_scale_viewport(xwl_window))
+        xwl_window_enable_viewport_for_fractional_scale(xwl_window, width, height);
+    else if (xwl_window_has_viewport_enabled(xwl_window))
+        xwl_window_disable_viewport(xwl_window);
+}
+
+static void
+xwl_window_rootful_set_app_id(struct xwl_window *xwl_window)
+{
+    //const char *app_id = "org.freedesktop.Xwayland";
+    //if (xwl_window->xdg_toplevel)
+    //    xdg_toplevel_set_app_id(xwl_window->xdg_toplevel, app_id);
+}
+
+static void
+xwl_window_maybe_resize(struct xwl_window *xwl_window, double width, double height)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct xwl_output *xwl_output;
+    double scale;
+    RRModePtr mode;
+
+    /* Clamp the size */
+    width = min(max(width, MIN_ROOTFUL_WIDTH), MAX_ROOTFUL_WIDTH);
+    height = min(max(height, MIN_ROOTFUL_HEIGHT), MAX_ROOTFUL_HEIGHT);
+
+    if (width == xwl_screen->width && height == xwl_screen->height)
+        return;
+
+    xwl_screen->width = width;
+    xwl_screen->height = height;
+
+    /* When fractional scale is used, the global surface scale is 1, and vice
+     * versa, so we can multiply the two here, and have the resulting scale
+     * apply for both cases, the legacy wl_surface buffer scale and fractional
+     * scaling.
+     */
+    scale *= xwl_window_get_fractional_scale_factor(xwl_window);
+
+    xwl_output = xwl_screen_get_fixed_or_first_output(xwl_screen);
+    if (!xwl_randr_add_modes_fixed(xwl_output, round(width / scale), round(height / scale)))
+        return;
+
+    xwl_window_attach_buffer(xwl_window);
+}
+
+static void
+xdg_surface_handle_configure(void *data,
+                             struct xdg_surface *xdg_surface,
+                             uint32_t serial)
+{
+    struct xwl_window *xwl_window = data;
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    if (xwl_screen->fullscreen)
+        xwl_window_set_fullscreen(xwl_window);
+}
+
+static void
+xwl_window_update_surface_scale(struct xwl_window *xwl_window)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    int previous_scale, new_scale;
+    double new_width, new_height;
+
+    previous_scale = xwl_screen->global_surface_scale;
+    assert(previous_scale != 0);
+    xwl_window->surface_scale = xwl_window_get_max_output_scale(xwl_window);
+
+    if (xwl_screen_update_global_surface_scale(xwl_screen)) {
+        new_scale = xwl_screen->global_surface_scale;
+
+        DebugF("XWAYLAND: Global scale is now %i (was %i)\n",
+               new_scale, previous_scale);
+
+        new_width = xwl_screen->width / previous_scale * new_scale;
+        new_height = xwl_screen->height / previous_scale * new_scale;
+
+        /* Reflect the scale factor using XRandR transform */
+        xwl_window_maybe_resize(xwl_window, new_width, new_height);
+    }
+}
+
+    static void
+xwl_window_free_outputs(struct xwl_window *xwl_window)
+{
+    struct xwl_window_output *window_output, *tmp;
+
+    xorg_list_for_each_entry_safe(window_output, tmp, &xwl_window->xwl_output_list, link) {
+        xorg_list_del(&window_output->link);
+        free(window_output);
+    }
+}
+
+
+
+static void
+xdg_toplevel_handle_close(void *data,
+                          struct xdg_toplevel *xdg_toplevel)
+{
+    DebugF("Terminating on compositor request");
+    GiveUp(0);
+}
+
+void
+xwl_window_update_surface_window(struct xwl_window *xwl_window)
+{
+    WindowPtr surface_window = xwl_window->toplevel;
+    ScreenPtr screen = surface_window->drawable.pScreen;
+    PixmapPtr surface_pixmap;
+    DamagePtr window_damage;
+    RegionRec damage_region;
+    WindowPtr window;
+
+    surface_pixmap = screen->GetWindowPixmap(surface_window);
+
+    for (window = surface_window->firstChild; window; window = window->firstChild) {
+        PixmapPtr window_pixmap;
+
+        if (!RegionEqual(&window->winSize, &surface_window->winSize))
+            break;
+
+        if (!window->mapped)
+            break;
+
+        /* The surface window must be top-level for its window pixmap */
+        window_pixmap = screen->GetWindowPixmap(window);
+        if (window_pixmap == surface_pixmap)
+            continue;
+
+        surface_pixmap = window_pixmap;
+
+        /* A descendant with alpha channel cannot be the surface window, since
+         * any non-opaque areas need to take the contents of ancestors into
+         * account.
+         */
+        if (window->drawable.depth == 32)
+            continue;
+
+        if (window->redirectDraw == RedirectDrawManual &&
+            !xwl_present_window_redirected(window))
+            break;
+
+        surface_window = window;
+    }
+
+    if (xwl_window->surface_window == surface_window)
+        return;
+
+    if (xwl_window->surface_window_damage) {
+        if (xwl_present_maybe_unredirect_window(xwl_window->surface_window) &&
+            screen->SourceValidate == xwl_source_validate) {
+            WindowPtr toplevel = xwl_window->toplevel;
+
+            xwl_source_validate(&toplevel->drawable,
+                                toplevel->drawable.x, toplevel->drawable.y,
+                                toplevel->drawable.width,
+                                toplevel->drawable.height,
+                                IncludeInferiors);
+        }
+
+        if (RegionNotEmpty(xwl_window->surface_window_damage))
+            need_source_validate_dec(xwl_window->xwl_screen);
+
+        RegionDestroy(xwl_window->surface_window_damage);
+        xwl_window->surface_window_damage = NULL;
+    }
+
+    window_damage = window_get_damage(xwl_window->surface_window);
+    if (window_damage) {
+        RegionInit(&damage_region, NullBox, 1);
+        RegionCopy(&damage_region, DamageRegion(window_damage));
+        unregister_damage(xwl_window);
+    }
+
+    if (surface_window->drawable.depth != xwl_window->surface_window->drawable.depth)
+        xwl_window_buffers_dispose(xwl_window, FALSE);
+
+    xwl_window->surface_window = surface_window;
+    register_damage(xwl_window);
+
+    if (window_damage) {
+        RegionPtr new_region = DamageRegion(window_get_damage(surface_window));
+
+        RegionUnion(new_region, new_region, &damage_region);
+        RegionUninit(&damage_region);
+    }
+}
+#endif
+
 static struct xwl_window *
 ensure_surface_for_window(WindowPtr window)
 {
@@ -207,20 +745,45 @@ ensure_surface_for_window(WindowPtr window)
     xwl_window->viewport_scale_y = 1.0;
     xwl_window->surface_scale = 1;
     xorg_list_init(&xwl_window->xwl_output_list);
+    //if (xwl_window->surface == NULL) {
+    //    ErrorF("wl_display_create_surface failed\n");
+    //    goto err;
+    //}
 
     if (!xwl_screen->rootless && !xwl_create_root_surface(xwl_window))
         goto err;
 
     send_surface_id_event(xwl_window);
 
+    //xwl_window_set_xwayland_tag(xwl_window);
+
     compRedirectWindow(serverClient, window, CompositeRedirectManual);
 
     dixSetPrivate(&window->devPrivates, &xwl_window_private_key, xwl_window);
     xorg_list_init(&xwl_window->link_damage);
+    //xorg_list_add(&xwl_window->link_window, &xwl_screen->window_list);
     xorg_list_init(&xwl_window->frame_callback_list);
 
+    //xwl_window_buffers_init(xwl_window);
+
+    //xwl_window_update_surface_window(xwl_window);
+
     xwl_window_init_allow_commits(xwl_window);
 
+    /* When a new window-manager window is realized, then the randr emulation
+     * props may have not been set on the managed client window yet.
+     */
+    //if (!xwl_screen->fullscreen) {// && window_is_wm_window(window)) {
+        //toplevel = window_get_client_toplevel(window);
+        //if (toplevel)
+        //    xwl_output_set_window_randr_emu_props(xwl_screen, toplevel);
+    //} else {
+        /* CSD or O-R toplevel window, check viewport on creation */
+        //xwl_window_check_resolution_change_emulation(xwl_window);
+    //}
+
+    //xwl_window_set_input_region(xwl_window, wInputShape(window));
+
     return xwl_window;
 
 err:
@@ -272,6 +835,10 @@ xwl_realize_window(WindowPtr window)
     if (!xwl_window)
         return FALSE;
 
+    //if (window == xwl_window->surface_window &&
+    //    !window_get_damage(window))
+    //    return register_damage(xwl_window);
+
     return TRUE;
 }
 
diff --git a/hw/xwindowserver/xwindowserver-window.h b/hw/xwindowserver/xwindowserver-window.h
index 1dcac9b3de406d9f4d39b2155a28e89051a14d8e..d2fd65bb958b814b2b85a5576bd7fe92d7b07c6e 100644
--- a/hw/xwindowserver/xwindowserver-window.h
+++ b/hw/xwindowserver/xwindowserver-window.h
@@ -98,8 +98,47 @@ struct xwl_window {
 };
 
 struct xwl_window *xwl_window_get(WindowPtr window);
+#if 0
+RegionPtr xwl_window_get_damage_region(struct xwl_window *xwl_window);
+struct xwl_window *xwl_window_from_window(WindowPtr window);
+
+void xwl_window_update_property(struct xwl_window *xwl_window,
+                                PropertyStateRec *propstate);
+Bool xwl_window_is_toplevel(WindowPtr window);
+void xwl_window_check_resolution_change_emulation(struct xwl_window *xwl_window);
+void xwl_window_rootful_update_title(struct xwl_window *xwl_window);
+void xwl_window_rootful_update_fullscreen(struct xwl_window *xwl_window,
+                                          struct xwl_output *xwl_output);
+void xwl_window_set_window_pixmap(WindowPtr window, PixmapPtr pixmap);
+void xwl_window_update_surface_window(struct xwl_window *xwl_window);
+
+void xwl_window_leave_output(struct xwl_window *xwl_window,
+                             struct xwl_output *xwl_output);
+int xwl_window_get_max_output_scale(struct xwl_window *xwl_window);
+#endif
 Bool xwl_realize_window(WindowPtr window);
 Bool xwl_unrealize_window(WindowPtr window);
+#if 0
+Bool xwl_change_window_attributes(WindowPtr window, unsigned long mask);
+void xwl_clip_notify(WindowPtr window, int dx, int dy);
+int xwl_config_notify(WindowPtr window,
+                      int x, int y,
+                      int width, int height, int bw,
+                      WindowPtr sib);
+void xwl_resize_window(WindowPtr window,
+                       int x, int y,
+                       unsigned int width, unsigned int height,
+                       WindowPtr sib);
+void xwl_move_window(WindowPtr window,
+                     int x, int y,
+                     WindowPtr next_sib,
+                     VTKind kind);
+Bool xwl_destroy_window(WindowPtr window);
+void xwl_window_post_damage(struct xwl_window *xwl_window);
+void xwl_window_create_frame_callback(struct xwl_window *xwl_window);
+void xwl_window_surface_do_destroy(struct xwl_wl_surface *xwl_wl_surface);
+void xwl_window_set_input_region(struct xwl_window *xwl_window, RegionPtr input_shape);
+#endif
 
 Bool xwl_window_init(void);
 
diff --git a/hw/xwindowserver/xwindowserver.c b/hw/xwindowserver/xwindowserver.c
index 3e00ceed06351a469951295141702efb3c07341b..0d3c49acdf250c8399339c07af3300a794924eab 100644
--- a/hw/xwindowserver/xwindowserver.c
+++ b/hw/xwindowserver/xwindowserver.c
@@ -102,6 +102,17 @@ InitOutput(ScreenInfo * screen_info, int argc, char **argv)
     xorgGlxCreateVendor();
 
     LocalAccessScopeUser();
+
+    //if (wm_fd >= 0 || init_fd >= 0) {
+    //    if (wm_fd >= 0)
+    //        TimerSet(NULL, 0, 1, add_client_fd, NULL);
+    //    if (init_fd >= 0)
+    //        ListenOnOpenFD(init_fd, FALSE);
+    //    AddCallback(&SelectionCallback, wm_selection_callback, NULL);
+    //}
+    //else if (listen_fd_count > 0) {
+    //    listen_on_fds();
+    //}
 }
 
 
